---
title: "EVST 496 Tree Giveaway Data"
subtitle: "Cleaning of Tree Giveaway Data of Holyoke, MA and Chelsea, MA"
author: "Eduardo Marin"
date: "`r format(Sys.time())`"
output:
  pdf_document:
    toc: true
  html_document:
    theme: flatly
    code_folding: hide
    fig_width: 8
    fig_height: 7
    fig_caption: true
    toc: true
    toc_float: true
    self_contained: true
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---

```{r Loading Packages, message=FALSE, include=FALSE}
# 1. Loading all packages
packs <-c(
            'janitor'    # cleans things up, also pipe-friendly cross-tabulations
           , 'sf'         # for spatial data support
          , 'tidyverse'  # cuz
          # , 'tidylog'    # prints out what was done in dplyr and tidyr
          , 'magrittr'   # for the pipe
          , 'mapview'    # web maps for zooming and panning around
          #, 'beepr'      # makes noise when things are done!
          , 'tictoc'     # timing things.
          , 'raster'
          # , 'doParallel' # does what is says! PARALLEL
          # 'broom.mixed',# tidiers for mixed models AND nlme::gls()
          # , 'lubridate'   # DATES!
          , 'tidycensus' # tidy census package
          , 'tidygeocoder' # geo coding
          , 'leaflet' #creating the interactive mapping elements (more specific)
          , 'shiny'
          , 'leafsync'  # linked maps
          , 'RColorBrewer'
          , 'DT'
          , 'openxlsx'
          , 'mapdeck'
          , 'biscale' #used with ggplot to make bivariate maps
          , 'cowplot' #used to make more aesthetic ggplot visuals
          , 'ggspatial' #creates a basemap for your ggplots
          , 'classInt' #find me breaks without doing manualcalculations
          , 'rgl' #needs for rayshader
          , 'rayshader' #good data viz for 3d bar graphs
          , 'leaflet' #for heatmaps and more unique, customizable maps
          , 'leaflet.extras'
          , 'tidytext'
          , 'scales'
          , 'readxl'
          )     

#2. If the packages in 'packs' are not already installed, install them
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packs, rownames(installed.packages())))
}
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)

# 3. Items for tidy census
census_api_key('58fc555c77c229747ade7d9fe50e7c71297cf91a', install = TRUE, overwrite = TRUE)
readRenviron("~/.Renviron")
options(tigris_use_cache = TRUE)
```

# 1. Reading the Chelsea, MA and Holyoke, MA Giveaway Data 
```{r Reading the Chelsea, MA & Holyoke, MA data}
# 1. Working with the Chelsea giveaway data
chelsea_giveaways <-
  read_csv("./input_data/Chelsea/Tree Giveaways/2017CorrectedChelseaAllTreesComplete.csv")

# 2. Working with the Holyoke giveaway data
holyoke_giveaways <-
  read_csv("./input_data/Holyoke/Tree Giveaways/holy_random_clean_fixed.csv") # DL: There appears to be no address information

```

```{r Transforming and messing with the data of Chelsea, MA eval=FALSE, include=FALSE}
#----------------#
# This does not need to be read. It was just some preliminary analysis done to understand the dates and what the data is trying to say
#----------------#

# 1. Checking if there are any duplicates in their IDs
chelsea_giveaways |>
  filter(duplicated(OID_) | duplicated(OID_, fromLast = TRUE))

chelsea_giveaways |> #All the the duplicates appear to be from TreID_1 that are NAs, so most likely, the one we should use is the OID_
  filter(!is.na(TreID_1)) |>
  filter(duplicated(TreID_1) | duplicated(TreID_1, fromLast = TRUE)) |>
  view()

# 2. Looking at unique values of certain categories
### a) Finding more general categories

#DHL here's another way to do that
chelsea_giveaways |>
  # st_drop_geometry() |> # not needed here but from the example I had already
  # select(-id) |>        # same, 
  mutate_if(is.character, as.factor) |> # factorize the characters
  select_if(is.factor) |>               # select the factor
  map(~tabyl(.)) |>                     # cross tabulate them all
  bind_rows(.id = 'var')                # combine and retain

# DATEPLANTE shoudl be a date, not a character or factor



sort(unique(chelsea_giveaways$GGC_PUB)) #GGC_Pub shows public or private
sort(unique(chelsea_giveaways$REPLACE))
sort(unique(chelsea_giveaways$COMMENT))
sort(unique(chelsea_giveaways$Cultivar))
sort(unique(chelsea_giveaways$Deciduous)) # Checks if it is either Decidious or Evergreen
sort(unique(chelsea_giveaways$Broadleaf)) # Checks if it is a Broadleaf or a Conifer
sort(unique(chelsea_giveaways$Native_Sta))
sort(unique(chelsea_giveaways$DBH_dcr)) # DBH measurements, I think
sort(unique(chelsea_giveaways$Hght_dc)) # Tree Height but needs cleaning
sort(unique(chelsea_giveaways$BSp_17))
sort(unique(chelsea_giveaways$Cmmnt_1)) # Comments on planting of the trees (EM: Should be mentioned as a potential bias/issue for the future)
sort(unique(chelsea_giveaways$StTp_17))
sort(unique(chelsea_giveaways$Wth_17))
sort(unique(chelsea_giveaways$Rnd_Smp))
sort(unique(chelsea_giveaways$DBH2H_17))
sort(unique(chelsea_giveaways$DBH1H_17)) #DL: This seems important; unsure what this is trying to measure
sort(unique(chelsea_giveaways$Com_24)) 

### b) Finding for specific years
####—Checking Hght_dc
chelsea_giveaways |>
  dplyr::select(GGC_YEA, Hght_dc) |>
  distinct() |>
  arrange(GGC_YEA, Hght_dc) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(Hght_dc, collapse = ", ")) |>
  print(n = Inf) # Hght_dc Appears to only track from 2021—2023

####—Checking BSp_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, BSp_17) |>
  distinct() |>
  arrange(GGC_YEA, BSp_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(BSp_17, collapse = ", ")) |>
  print(n = Inf) #BSp_17 Appears to only only track from 2014—2016

####—Checking DBH1_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, DBH1_17) |>
  distinct() |>
  arrange(GGC_YEA, DBH1_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(DBH1_17, collapse = ", ")) |>
  print(n = Inf) #DBH1_17 seems to have only be tracked from 2014—2016

####—Checking DBH_dcr
chelsea_giveaways |>
  dplyr::select(GGC_YEA, DBH_dcr) |>
  distinct() |>
  arrange(GGC_YEA, DBH_dcr) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(DBH_dcr, collapse = ", ")) |>
  print(n = Inf) # DBH_dcr seems to have only tracked from 2021—2023

####—Checking LUse_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, LUse_17) |>
  distinct() |>
  arrange(GGC_YEA, LUse_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(LUse_17, collapse = ", ")) |>
  print(n = Inf) # LUse_17 seems to have only be tracked from 2014—2016

####—Checking M_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, M_17) |>
  distinct() |>
  arrange(GGC_YEA, M_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(M_17, collapse = ", ")) |>
  print(n = Inf) # M_17 seems to be survivorship; but it is only tracked from 2014—2016

####—Checking StTp_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, StTp_17) |>
  distinct() |>
  arrange(GGC_YEA, StTp_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(StTp_17, collapse = ", ")) |>
  print(n = Inf) # StTp_17 seems to have only be tracked from 2014—2016

####—Checking V_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, V_17) |>
  distinct() |>
  arrange(GGC_YEA, V_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(V_17, collapse = ", ")) |>
  print(n = Inf) # V_17 seems to have only be tracked from 2014—2016

####—Checking Wth_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, Wth_17) |>
  distinct() |>
  arrange(GGC_YEA, Wth_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(Wth_17, collapse = ", ")) |>
  print(n = Inf) # Wth_17 seems to be width and it has have only been tracked from 2014—2016

####—Checking DBH2H_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, DBH2H_17) |>
  distinct() |>
  arrange(GGC_YEA, DBH2H_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(DBH2H_17, collapse = ", ")) |>
  print(n = Inf) # DBH2H_17 seems to not have anything worthwhile

####—Checking DBH1H_17
chelsea_giveaways |>
  dplyr::select(GGC_YEA, DBH1H_17) |>
  distinct() |>
  arrange(GGC_YEA, DBH1H_17) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(DBH1H_17, collapse = ", ")) |>
  print(n = Inf) # DBH1H_17 seems to not have anything worthwhile

####—Checking StTp_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, StTp_24) |>
  distinct() |>
  arrange(GGC_YEA, StTp_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(StTp_24, collapse = ", ")) |>
  print(n = Inf) # StTp_24 seems to have all years DL: wondering why did they include just the FY BY for the year 2014—2016 separate. 

####—Checking LUse_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, LUse_24) |>
  distinct() |>
  arrange(GGC_YEA, LUse_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(LUse_24, collapse = ", ")) |>
  print(n = Inf) # LUse_24 seems to have all land uses. Again, DL: wondering why did they include the land use for the year 2014—2016 separate.

####—Checking Bsp_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, Bsp_24) |>
  distinct() |>
  arrange(GGC_YEA, Bsp_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(Bsp_24, collapse = ", ")) |>
  print(n = Inf) # Bsp_24 seems to have all the basal sprouts. Seems less comprehensive than before

####—Checking V_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, V_24) |>
  distinct() |>
  arrange(GGC_YEA, V_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(V_24, collapse = ", ")) |>
  print(n = Inf) # V_24 seems to have all the vigor and they are connected to the presentation slide values

####—Checking Con_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, Con_24) |>
  distinct() |>
  arrange(GGC_YEA, Con_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(Con_24, collapse = ", ")) |>
  print(n = Inf) # Con_24 conditions for all years

####—Checking DBH1_24
chelsea_giveaways |>
  dplyr::select(GGC_YEA, DBH1_24) |>
  distinct() |>
  arrange(GGC_YEA, DBH1_24) |>
  group_by(GGC_YEA) |>
  summarise(List = paste(DBH1_24, collapse = ", ")) |>
  print(n = Inf) # DBH1_24 conditions for all years

# DL: Would not do this with the Holyoke, looked at the data and figured it was the same format as the Chelsea
```

# 2. Cleaning the Chelsea, MA Giveaway Data 
```{r Reading and Cleaning Giveaway Data Chelsea, echo=TRUE, message=FALSE}
# 1. Overview of all the variables (including all of the years surveyed)
chelsea_giveaway_overview <-
  chelsea_giveaways |>
    rename(
      Date_Planted                 = DATEPLANTE
    , Address                      = nw_ddrs
    , Public_Private               = GGC_PUB
    , Comment_General              = COMMENT
    , Cultivar                     = Cultivar
    , Year_Planted                 = GGC_YEA
    , Season_Planted               = GGC_SEA
    , City                         = CITY_GG
    , Family                       = Family
    , Genus                        = Genus
    , Deciduous_Evergreen          = Deciduous 
    , Broadleaf_Conifer            = Broadleaf
    , Species                      = Species
    , Native_Status                = Native_Sta
    , DBH_2021_2023                = DBH_dcr
    , Height_Unformatted_2021_2023 = Hght_17 # Needs cleaning
    , Owner_Address_P1             = ADDRESS # Needs double checking here
    , Owner_Address_P2             = OWNERAD # Needs standardization
    , Basal_Sprouts_2014_2016      = BSp_17
    , Comment_Survey_2017          = Cmmnt_1
    , DBH_2014_2016                = DBH1_17
    , Mortality_Status_2014_2016   = M_17
    , Vigor_2014_2016              = V_17
    , Land_Use_2014_2016           = LUse_17
    , Site_Type_2014_2016          = StTp_17  
    , Width_2014_2016              = Wth_17
    , Common_Name                  = CommonName
    , Unique_ID_New                = NewTrID # DL: Which one should I use?
    , Site_Type_2014_2023          = StTp_24
    , Land_Use_2014_2023           = LUse_24
    , Basal_Sprouts_2014_2023      = Bsp_24   # Seems to be less comprehensive
    , Vigor_2014_2023              = V_24
    , Conditions_2014_2023         = Con_24 # Condition for all the years
    , Comment_Survey_2024          = Com_24
    , DBH_2014_2023                = DBH1_24
    , Height_2014_2023             = Hgt_24
    , Width_2014_2023              = Wth_24
    , Date_Surveyed                = D_24
    , Mortality_Status_2014_2023   = M_24
    , Date_Inserted                = CreationDate
    , Author_Inserted              = Creator
    , Date_Edited                  = EditDate
    , Author_Edited                = Editor
    , Easting                      = X
    , Northing                     = Y
  ) 
   
# Removing these columns: 
## TreID_1 — appears to have more NAs and not the real address
## RD_NUM — appears to be the road number
## RD_NUMB — appears to be the road number but less selective
## RD_NAME — appears to be the road name
## RD_SUFF — appears to be the road suffix: ex. Ave, St, etc. 
## DBH2_17 — appears to have only 2015 data that is insufficient compared to DBH1_17
## V_17 — appears to be vigor but the values make no sense (for those reasons, currently not including until #         further information is provided)
## Rnd_Smp — appears to be an abbreviation of random sample; not sure what this could help us in [gives    
#            values of only 0, 1]
## H17_Smp — appears to be maybe an abbreviation for height; not sure if this is important [gives values of
#            only 0, 1]
## DBH2H_17 — appears to only have three values—0, 21, 54; seems useless
## HERO2017 — appears to only have the value of 1, unsure how helpful 
## DBH1H_24 — appears to only be a larger scale x10 of the DBH that we saw earlier
## DBH2_24 — unsure what this is
## DBH2H_24 — unsure what this is

# 2. Selected variables for further analysis
pre_chelsea_giveaway_analysis <- 
  chelsea_giveaway_overview |>
  dplyr::select (
      Unique_ID_New                
    , Address                  
    # , Owner_Address_P1             
    # , Owner_Address_P2             
    , City                         
    , Date_Planted                 
    , Year_Planted                 
    , Season_Planted               
    # , Date_Surveyed                
    # , Date_Inserted                
    # , Author_Inserted              
    # , Date_Edited                  
    # , Author_Edited                
    , Family                       
    , Genus                        
    , Species                      
    , Cultivar                     
    , Common_Name                  
    , Native_Status                
    , Deciduous_Evergreen          
    , Broadleaf_Conifer            
    , Public_Private               
    , Land_Use_2014_2023           
    , Site_Type_2014_2023          
    , Vigor_2014_2023              
    , Mortality_Status_2014_2023
    , Conditions_2014_2023         
    , DBH_2014_2023                
    , Height_2014_2023             
    , Width_2014_2023              
    , Basal_Sprouts_2014_2023      
    , Comment_General              
    , Comment_Survey_2017             
    , Comment_Survey_2024          
    , Easting                      
    , Northing                     
  ) |>
  mutate(Year_Planted = as.character(Year_Planted)) #Need this for the merge


# 3. Getting the lat and long of the variables for further analysis
## a) Transforming into an SF object based off of Massachusetts State Plane, NAD83, feet
temp_chelsea_sf <- 
  pre_chelsea_giveaway_analysis |>
  st_as_sf(coords = c("Easting", "Northing"), crs = 26986) |>
  st_transform(crs = 4326)  

## b) Receiving the coordinates data
temp_chelsea_coords <- 
  st_coordinates(temp_chelsea_sf)

## c) Appending the coordinate data  
pre_chelsea_giveaway_analysis$Longitude <- temp_chelsea_coords[,1]
pre_chelsea_giveaway_analysis$Latitude  <- temp_chelsea_coords[,2]

```

# 3. Cleaning the Holyoke, MA Giveaway Data 
```{r Reading and Cleaning Giveaway Data Chelsea, echo=TRUE, message=FALSE}
# 1. Comparing the columns to see which ones need to be changed from before
compare_df_cols(chelsea_giveaways, holyoke_giveaways) |>
  as_tibble() |>
  print(n = Inf) # Needed this to help me clear out some of the columns/rows

# 2. Overview of all the variables (including all of the years surveyed)
holyoke_giveaway_overview <-
  holyoke_giveaways |> 
    rename(
      # Unique_ID                    = OID_
      Date_Planted                 = DATEPLANTE
      # New_Address                  = nw_ddrs
    , Public_Private               = Pub_Priv
      # Comment_General              = COMMENT
    , Cultivar                     = Cultivar
      # Year_Planted                 = GGC_SEA
      # Season_Planted               = GGC_SEA
      # City                         = CITY_GG
    , Family                       = Family
    , Genus                        = Genus
    , Deciduous_Evergreen          = Deciduous
      # Broadleaf_Conifer            = Broadleaf
    , Species                      = Species
    , Native_Status                = Native_Sta
    # , DBH_2021_2023                = DBH_dcr
    , Height_Unformatted_2021_2023 = Hgt_17 # Needs cleaning
    # , Owner_Address_P1             = ADDRESS # Needs double checking here
    # , Owner_Address_P2             = OWNERAD # Needs standardization
    , Basal_Sprouts_2014_2016      = BSp_17
      # Comment_Planting             = Cmmnt_1
    , DBH_2014_2016                = DBH1_17
    , Mortality_Status_2014_2016   = M_17
    , Vigor_2014_2016              = V_17
    , Land_Use_2014_2016           = LUse_17
    , Site_Type_2014_2016          = StTp_17  
    , Width_2014_2016              = Wth_17
    , Common_Name                  = commonName
    , Unique_ID_New                = NewTreeID # DL: Which one should I use?
    , Site_Type_2014_2023          = StTp_24
    , Land_Use_2014_2023           = LUse_24
    , Basal_Sprouts_2014_2023      = BSp_24 # Seems to be less comprehensive
    , Vigor_2014_2023              = V_24
    , Conditions_2014_2023         = Con_24 # Condition for all the years
      # Comment_Survey_2024          = Com_24
    , DBH_2014_2023                = DBH1_24
    , Height_2014_2023             = Hgt_24
    , Width_2014_2023              = Wth_24
    , Date_Surveyed                = Date_24
    , Mortality_Status_2014_2023  = M_24
      # Date_Inserted                = CreationDate
      # Author_Inserted              = Creator
      # Date_Edited                  = EditDate
      # Author_Edited                = Editor
    , Northing                     = lat  # EM: Fix to make lat, long,
    , Easting                    = long  # EM: Fix to make lat, long,
    ) |>
   mutate(City = "HOLYOKE"                      # Need to add for the bind and select in the future
       , Broadleaf_Conifer = NA_character_
       , Comment_General = NA_character_
       , Comment_Survey_2017 = NA_character_
       , Comment_Survey_2024 = NA_character_
       , Address = NA_character_
       , Year_Planted =  NA_character_
       , Season_Planted = NA_character_
   ) 
  
  
# 3a. Figuring out which columns to select for the new one
compare_df_cols(pre_chelsea_giveaway_analysis, holyoke_giveaway_overview) |>
  as_tibble() |>
  print(n = Inf) 

# 3b. Selecting the variables that are in common
pre_holyoke_giveaway_analysis <- 
  holyoke_giveaway_overview |>
  dplyr::select (
      Unique_ID_New                
    , Address                  
    # , Owner_Address_P1             
    # , Owner_Address_P2             
    , City
    , Date_Planted                 
    , Year_Planted                 
    , Season_Planted               
    # , Date_Surveyed                
    # , Date_Inserted                
    # , Author_Inserted              
    # , Date_Edited                  
    # , Author_Edited                
    , Family                       
    , Genus                        
    , Species                      
    , Cultivar                     
    , Common_Name                  
    , Native_Status                
    , Deciduous_Evergreen          
    , Broadleaf_Conifer            
    , Public_Private               
    , Land_Use_2014_2023           
    , Site_Type_2014_2023          
    , Vigor_2014_2023              
    , Mortality_Status_2014_2023   
    , Conditions_2014_2023         
    , DBH_2014_2023                
    , Height_2014_2023             
    , Width_2014_2023              
    , Basal_Sprouts_2014_2023      
    , Comment_General
    , Comment_Survey_2017
    , Comment_Survey_2024
    , Easting                      
    , Northing                     
  ) 

# 4. Getting the lat and long of the variables for further analysis
## a) Transforming into an SF object based off of Massachusetts State Plane, NAD83, feet
temp_holyoke_sf <- 
  pre_holyoke_giveaway_analysis |>
  st_as_sf(coords = c("Easting", "Northing"), crs = 26986) |>
  st_transform(crs = 4326)  

## b) Receiving the coordinates data
temp_holyoke_coords <- 
  st_coordinates(temp_holyoke_sf)

## c) Appending the coordinate data  
pre_holyoke_giveaway_analysis$Longitude <- temp_holyoke_coords[,1]
pre_holyoke_giveaway_analysis$Latitude  <- temp_holyoke_coords[,2]

# 5. Reverse geocoding for the addresses
## a) Finding all the addresses to append
# giveaway_with_addresses <- 
#   pre_holyoke_giveaway_analysis |>
#   reverse_geocode(
#     lat = Latitude,
#     long = Longitude,
#     method = "arcgis",     
#     full_results = TRUE    
#   )

## b) Creating new data frame to append
# shortlabel_data <- 
#   giveaway_with_addresses |>
#   dplyr::select(Unique_ID_New, ShortLabel)

## c) Appending the data
# pre_holyoke_giveaway_analysis <-
#   pre_holyoke_giveaway_analysis |>
#   left_join(shortlabel_data, by = "Unique_ID_New") |>
#   mutate(Address = ShortLabel) |>
#   dplyr::select(-ShortLabel)

# Approximately ~110 that need fixing; DL: not sure how urgent since we are not doing analysis with address, but added it so it was nice to have

# 6. Comparing the columns again
compare_df_cols(pre_chelsea_giveaway_analysis, pre_holyoke_giveaway_analysis) |>
  as_tibble() |>
  print(n = Inf) 

```

# 4. Combining the Chelsea, MA and Holyoke, MA Giveaway Data
```{r}
pre_hero_tree_giveaway <- 
  bind_rows(
    pre_chelsea_giveaway_analysis
  , pre_holyoke_giveaway_analysis
    ) |>
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) 
```

# 5. Creating the appending columns for the final HERO Giveaway Dataset
```{r}
# 1a. Creating summary table of Broadleaf and Conifers for a join
pre_broadleaf_conifer_table_v1 <- 
  pre_hero_tree_giveaway |>
  st_drop_geometry() |>
  filter(!is.na(Broadleaf_Conifer)) |> 
  group_by(Species, Broadleaf_Conifer) |>  
  summarize(Count = n(), .groups = "drop") |> 
  arrange(Species) |>
  dplyr::select(-Count) 

# 1b. Checking if there any duplicates here
pre_broadleaf_conifer_table_v1 |>
  count(Species) |>
  filter(n > 1) # Nope, so they are all unique :)

# 1c. Creating a tibble of the future missing Broadleaf_Conifer categorizations
pre_broadleaf_conifer_table_v2 <- 
  tribble(
  ~Species,                      ~Broadleaf_Conifer
  , "Aesculus hippocastanum"  , "Broadleaf"                     
  , "Aesculus x carnea"       , "Broadleaf"               
  , "Amelanchier canadensis"  , "Broadleaf"                 
  , "Eucommia ulmoides"       , "Broadleaf"             
  , "Halesia monticola"       , "Broadleaf"             
  , "Malus x domestica"       , "Broadleaf"           
  , "Prunus avium"            , "Broadleaf"       
  , "Prunus persica"          , "Broadleaf"           
  , "Prunus salicina"         , "Broadleaf"           
  , "Pyrus communis"          , "Broadleaf"          
  , "Sorbus alnifolia"        , "Broadleaf"             
  , "Styrax japonicus"        , "Broadleaf"               
  , "Thuja plicata"           , "Conifer"         
  , "Ulmus parvifolia"        , "Broadleaf"             
  , "Ulmus spp."              , "Broadleaf"
  )

# 1d. Combining both tables for the join
broadleaf_conifer_table <-
 bind_rows(
    pre_broadleaf_conifer_table_v1,
    pre_broadleaf_conifer_table_v2
    ) 

# 2a. Creating the iTree Final Table
pre_i_tree_table_v1 <- 
  read_excel(
    "./input_data/General/Create_iTree_spp_codes_from_inventory_list.xls.xlsx" # DHL that's a weird file extension, is that right?
  , sheet = "i-Tree Species List"
  ) |>
 mutate( #This is to make it mergeable
    Species = str_c(`Genus Name`, `Species Name`, sep = " "),
    Species = str_to_lower(Species),
    Species = str_replace(Species, "^\\w", toupper(str_sub(Species, 1, 1)))  #Ensures the first letter is capitalized
  ) |>
  rename(Height_Maturity = `Height at Maturity (feet)`
       , i_Tree_Code        = `Species Code`
       , Growth_Form        = `Growth Form`
       , Percent_Leaf_Type  = `Percent Leaf Type`
       , Leaf_Type          = `Leaf Type`
       , Growth_Rate        = `Growth Rate`
       )

# 2b. Checking the unmatched species
matched_species <- #Finding those matched
  pre_hero_tree_giveaway$Species %in% pre_i_tree_table_v1$Species # DHL does not run.

#Finding those unmatched # DHL use %nin% or dplyr::anti_join or tidylog::anti_join for clarity and sanity instead.
  unique(pre_hero_tree_giveaway$Species[!(pre_hero_tree_giveaway$Species %in% pre_i_tree_table_v1$Species)])
  
# 2c. Creating the index table and reading it in
pre_i_tree_table_v2 <- 
  read_excel("./input_data/General/i_Tree_Appendix.xls.xlsx"
           , sheet = "i-Tree Species List"
           , n_max = 19) |>
  dplyr::select(1:8)
# DL: There are some odd species without a noticaebale TREEID, being the following: Quercus x warei, Prunus x incam, Malus x domestica. Other [genus spp.] had little to no information—those were also not helpful

# 2d. Merging both index tables for future i-Tree analysis
i_tree_table <- 
  bind_rows(
    pre_i_tree_table_v1
  , pre_i_tree_table_v2
    ) |>
  dplyr::select(-`Genus Name`, -`Species Name`, -Synonym, -Family, -Order, -Class, -`Common Name`)

```

# 6. Making the final HERO Giveaway Dataset
```{r}
# 1. Creating the final HERO tree giveaway table
hero_tree_giveaway <- 
  pre_hero_tree_giveaway |>
  mutate(Address = str_to_upper(Address)
       , Public_Private = str_to_title(Public_Private)) |> #Making all the addresses capitals
  arrange(City, Address) |>
  mutate(Row_ID = row_number()) |> # Need this since Unique_ID_New isn't really unique
  mutate(Date_Planted = mdy(Date_Planted)) |>
  mutate(Date_Planted = if_else(is.na(Date_Planted), as.Date("2021-05-19"), Date_Planted)) |> 
  mutate(
    Year_Planted = year(Date_Planted),
    Month = month(Date_Planted),
    Season_Planted = case_when(
      Month %in% c(3, 4, 5, 6, 7) ~ "SPRING" #DL: Should we include July in Spring? # DHL ask John Rogan
    , Month %in% c(8, 9, 10, 11) ~ "FALL" #DL: Should we include August in Fall?
    , TRUE ~ NA_character_      
    )
  ) |>
  dplyr::select(-Month, -Broadleaf_Conifer) |>
  mutate(Vigor_2014_2023 = as.character(Vigor_2014_2023)
       , Vigor_2014_2023 = case_when(
            Vigor_2014_2023 == "1" ~ "100% to 90% Full"
          , Vigor_2014_2023 == "2" ~ "90% to 75% Full"
          , Vigor_2014_2023 == "3" ~ "75% to 50% Full"
          , Vigor_2014_2023 == "4" ~ "50% or less"
          , Vigor_2014_2023 == "5" ~ "Unsure" #DL: I need to ask based on the presentation!
          , TRUE ~ Vigor_2014_2023)
       , Site_Type_2014_2023 = case_when(
            Site_Type_2014_2023 == "SC" ~ "Sidewalk Cutout"
          , Site_Type_2014_2023 == "BY" ~ "Backyard"
          , Site_Type_2014_2023 == "FY" ~ "Front Yard"
          , Site_Type_2014_2023 == "OM" ~ "Other Maintained"
          , Site_Type_2014_2023 == "SY" ~ "Side Yard"
          , Site_Type_2014_2023 == "MP" ~ "Maintained Park"
          , Site_Type_2014_2023 == "SP" ~ "Sidewalk Planting Strip"
          , TRUE ~ Site_Type_2014_2023)
       , Land_Use_2014_2023 = case_when(
         # DHL case_when works here, a small table and a left_join can also accomplish this. Tomatoe Tomatoe
            Land_Use_2014_2023 == "MFR"   ~ "Multi-Family Residential"               
          , Land_Use_2014_2023 == "SFR-D" ~ "Single-Family Detached"               
          , Land_Use_2014_2023 == "SFR-A" ~ "Single-Family Attached"               
          , Land_Use_2014_2023 == "INST"  ~ "Institutional"               
          , Land_Use_2014_2023 == "COMM"  ~ "Commercial"               
          , Land_Use_2014_2023 == "MP"    ~ "Maintained Park"               
          , Land_Use_2014_2023 == "V"     ~ "Vacant"      
          , Land_Use_2014_2023 == "MX"    ~ "Mixed Use"            
          , Land_Use_2014_2023 == "IND"   ~ "Industrial"              
          , Land_Use_2014_2023 == "O"     ~ "Other"            
          , Land_Use_2014_2023 == "TR"    ~ "Transportation"               
          , Land_Use_2014_2023 == "UT"    ~ "Unsure" #DL: I need to ask based on the presentation 
          , TRUE ~ Land_Use_2014_2023)
        , General_Location_2014_2023 = case_when(
            Site_Type_2014_2023 %in% c("Sidewalk Cutout", "Sidewalk Planting Strip") ~ "Street Trees"
          , Site_Type_2014_2023 %in% c("Backyard", "Front Yard", "Side Yard") ~ "Yard Trees"
          , Site_Type_2014_2023 %in% c("Other Maintained", "Maintained Park") ~ "Maintained Area"
          , TRUE ~ NA_character_)
              ) |>
    left_join(broadleaf_conifer_table, by = "Species") |>
    left_join(i_tree_table, by = "Species") |>
    dplyr::select(
      , Row_ID        
      , Address                  
      , City
      , Date_Planted                 
      , Year_Planted                 
      , Season_Planted               
      , Family                       
      , Genus                        
      , Species                      
      , Cultivar                     
      , Common_Name
      , i_Tree_Code
      , Growth_Form
      , Percent_Leaf_Type
      , Leaf_Type
      , Growth_Rate
      , Longevity
      , Height_Maturity
      , Native_Status                
      , Deciduous_Evergreen          
      , Broadleaf_Conifer            
      , Public_Private               
      , Land_Use_2014_2023    
      , General_Location_2014_2023
      , Site_Type_2014_2023          
      , Vigor_2014_2023              
      , Mortality_Status_2014_2023   
      , Conditions_2014_2023         
      , DBH_2014_2023                
      , Height_2014_2023             
      , Width_2014_2023              
      , Basal_Sprouts_2014_2023      
      , Comment_General
      , Comment_Survey_2017
      , Comment_Survey_2024
      , Unique_ID_New   
    ) |>
    rename(
        Land_Use         = Land_Use_2014_2023                         
      , General_Location = General_Location_2014_2023                     
      , Site_Type        = Site_Type_2014_2023                               
      , Vigor            = Vigor_2014_2023                                   
      , Mortality        = Mortality_Status_2014_2023                        
      , Conditions       = Conditions_2014_2023                              
      , DBH              = DBH_2014_2023       
      , Height           = Height_2014_2023         
      , Width            = Width_2014_2023          
      , Basal_Sprouts    = Basal_Sprouts_2014_2023  
      , New_Tree_ID      = Unique_ID_New #Had a change of mind and wanted to continue having the ID name that was there before
    )

hero_tree_giveaway #Yay :). Should be fully cleaned now and organized. 

```

# 7. Writing it out and future double-checks for the final giveaway dataset
```{r}
# 1. Writing out the dataset
hero_tree_giveaway |>
  st_write(paste0("output_data/hero_tree_giveaway_", Sys.Date(), ".gpkg"))

# Moved in the .gpkg to the input General folder

# 2. DL: If you want to do double checks. I suggest downloading mine which has the 
# direct reverse geocoded so you do not have to go through that process; I commented it out momentarily.
check_hero_tree_giveaway <-
st_read("./input_data/General/hero_tree_giveaway_2025-04-27.gpkg")
# DHL: no changes suggested here, but that would have been nice to know up top :-)
# DHL: no changes suggested here, but you seem to have a lot folders called "General". Be careful you may fool yourself

# missingness
check_hero_tree_giveaway  |> 
 map(~sum(is.na(.))) |>
 bind_rows() |>
 t()

# categorical / text
check_hero_tree_giveaway |> 
  st_drop_geometry() |>
  tidylog::select(-Address) |> 
  mutate_if(is.character, as.factor) |>
  select_if(is.factor) |>
  map(~tabyl(.)) |>
  bind_rows(.id = 'var') |> View()

check_hero_tree_giveaway |> mapview(zcol = 'Year_Planted')

check_hero_tree_giveaway |> 
  st_drop_geometry() |> 
  tabyl(Site_Type)

check_hero_tree_giveaway |> 
  st_drop_geometry() |> 
  group_by(Site_Type, City) |> 
  count() |> 
  ggplot(aes(n, Site_Type)) +
  geom_col() +
  facet_wrap(~City) +
  theme_bw(16) +
  NULL

check_hero_tree_giveaway |> 
  st_drop_geometry() |> 
  tabyl(Site_Type, City) |> 
  adorn_percentages() |> 
  pivot_longer(-Site_Type) |> 
  ggplot(aes(value, Site_Type)) +
  geom_col() +
  facet_wrap(~name) +
  theme_bw(16) +
  NULL
 
# eh not really what I was going for.
check_hero_tree_giveaway |> 
  st_drop_geometry() |> 
  filter(Site_Type == 'Front Yard' | Site_Type == 'Backyard') |> 
  tabyl(Year_Planted, City, Site_Type) |> 
  adorn_percentages() |> 
  bind_rows(.id = "Site_Type") |> 
  pivot_longer(-c(Site_Type, Year_Planted)) |> 
  ggplot(aes(value, Site_Type, fill = Year_Planted)) +
  geom_col() +
  facet_wrap(~name) +
  theme_bw(16) +
  NULL

```

