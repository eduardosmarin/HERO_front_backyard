---
title: "EVST 496 Census Data"
subtitle: "Census Comparison of Holyoke, MA and Chelsea, MA and Appending"
author: "Eduardo Marin"
date: "`r format(Sys.time())`"
output:
  pdf_document:
    toc: true
  html_document:
    theme: flatly
    code_folding: hide
    fig_width: 8
    fig_height: 7
    fig_caption: true
    toc: true
    toc_float: true
    self_contained: true
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---


# 0. Loading the packages
```{r 1. Loading Packages, message=FALSE, include=FALSE}
# 1. Loading all packages

knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,   # <--- this suppresses warnings
  message = FALSE    # <--- this suppresses messages
)

packs <-c(
            'janitor'    # cleans things up, also pipe-friendly cross-tabulations
           , 'sf'         # for spatial data support
          , 'tidyverse'  # cuz
          # , 'tidylog'    # prints out what was done in dplyr and tidyr
          , 'magrittr'   # for the pipe
          , 'mapview'    # web maps for zooming and panning around
          #, 'beepr'      # makes noise when things are done!
          , 'tictoc'     # timing things.
          , 'raster'
          # , 'doParallel' # does what is says! PARALLEL
          # 'broom.mixed',# tidiers for mixed models AND nlme::gls()
          # , 'lubridate'   # DATES!
          , 'tidycensus' # tidy census package
          , 'tidygeocoder' # geo coding
          , 'leaflet' #creating the interactive mapping elements (more specific)
          , 'shiny'
          , 'leafsync'  # linked maps
          , 'RColorBrewer'
          , 'DT'
          , 'openxlsx'
          , 'mapdeck'
          , 'biscale' #used with ggplot to make bivariate maps
          , 'cowplot' #used to make more aesthetic ggplot visuals
          , 'ggspatial' #creates a basemap for your ggplots
          , 'classInt' #find me breaks without doing manualcalculations
          , 'rgl' #needs for rayshader
          , 'rayshader' #good data viz for 3d bar graphs
          , 'leaflet' #for heatmaps and more unique, customizable maps
          , 'leaflet.extras'
          , 'tidytext'
          , 'scales'
          , 'ggspatial'
          , 'ggrepel'
          , 'httr' # needed to help me read in the property parcel 
          , 'jsonlite' # needed to help me read in the property parcel (p2)
          )     

#2. If the packages in 'packs' are not already installed, install them
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packs, rownames(installed.packages())))
}
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)

# 3. Items for tidy census
census_api_key('58fc555c77c229747ade7d9fe50e7c71297cf91a', install = TRUE, overwrite = TRUE)
readRenviron("~/.Renviron")
options(tigris_use_cache = TRUE)
```

# 1. Downloading the US Census Bureau ACS Data and Filtering out for Holyoke, MA & Chelsea, MA 
```{r Downloading US Census and Organizing Holyoke, MA & Chelsea, MA, echo=FALSE, message=FALSE}
# 1. Loading the list of variables from ACS
# variables_acs <-
#   tidycensus::load_variables('acs5', year = 2021) |>
#   filter(geography == "block group")

# 2. Loading the list of variables from ACS 
# my_vars <-  c(  #DL: For the variables, should I calculate percentage for aspects like renter and owner occupied; may need to be weighted since its estimated population is not based on the total population but something separate
       #   'median_household_income' = 'B19013_001'
       # , 'total_population' = 'B01003_001'
       # , 'households' = 'B11001_001'
       # , 'white_alone' = 'B03002_003'
       # , 'black_alone' = 'B03002_004'
       # , 'american_indian_alone' = 'B03002_005'
       # , 'asian_alone' = 'B03002_006'
       # , 'native_hawaiian_alone' = 'B03002_007'
       # , 'other_alone' = 'B03002_008'
       # , 'two_or_more_alone' = 'B03002_009'
       # , 'hispanic_alone' = 'B03002_012'
       # , 'labor_force_total' = 'B23025_003'
       # , 'unemployed_total' = 'B23025_005'
       # , 'median_age' = 'B01002_001'
       # , 'total_population_over_25' = 'B15003_001'
       # , 'ed_hs_degree' = 'B15003_017'
       # , 'ed_ged_degree' = 'B15003_018'
       # , 'ed_college_less_1_year' = 'B15003_019'
       # , 'ed_college_more_1_year' = 'B15003_020'
       # , 'ed_associate_degree' = 'B15003_021'
       # , 'ed_plus_bachelor_degree' = 'B15003_022'
       # , 'ed_plus_master_degree' = 'B15003_023'
       # , 'ed_plus_professional_degree' = 'B15003_024'
       # , 'ed_plus_doctorate_degree' = 'B15003_025'
       # , 'median_gross_rent' = 'B25064_001'
       # , 'median_home_value' = 'B25077_001'
       # , 'owner_occupied' = 'B25003_002'
       # , 'renter_occupied' = 'B25003_003'
       #      )
# 
# # 3. Loading the CBGs
# cbg_massachusetts <-
#   tidycensus::get_acs(
#       geography = 'block group'
#     , state = 'Massachusetts'
#     , variables = my_vars
#     , year = 2021
#     , geometry = TRUE
#     , output = 'wide'
#     , moe_level = 95
#     ) |>
#     st_transform(crs = st_crs(4326)) |> # DHL: why transform to this projection? Any issues with 4269? Just curious | EM: I think since mapview likes 4326 better, but I might be mistakened
#     dplyr::select(-ends_with("M")) |>
#     rename_with(~ gsub("E$", "", .x), ends_with("E")) |>
#     rename(NAME = NAM) |>
#     separate(NAME, into = c("Block", "Census Tract", "County", "State"), sep = ", ") |> #Added this for more complexity and        clarity
#     mutate(
#       pct_at_least_hs = (rowSums(across(starts_with("ed_"))))/total_population_over_25, #This gets percentage
#       pct_at_least_college = (rowSums(across(starts_with("ed_plus"))))/total_population_over_25 #This gets percentage
#     ) |>
#     dplyr::select(-starts_with("ed_"))

# write out
# cbg_massachusetts |>
#   st_write(paste0('input_data/cbg_massachusetts_', Sys.Date(), '.gpkg'))

# read in 
# cbg_massachusetts <- st_read('input_data/cbg_massachusetts_2025-04-28.gpkg')

# 4. Reading the geopackages
# holyoke_boundary <-
#   st_read("./input_data/Holyoke/Boundaries/holyoke_boundary.gpkg") |>
#   st_transform(st_crs(cbg_massachusetts))

# chelsea_boundary <-
#   st_read("./input_data/Chelsea/Boundaries/chelsea_boundary.gpkg") |>
#   st_transform(st_crs(cbg_massachusetts))

# 5. Select block groups that fall within each boundary
## a) Finding CBGs for Chelsea
# cbgs_chelsea <- 
#   # this is basically clipping the block groups, you may not want to modify the edges.
#   cbg_massachusetts[
#   st_intersects(cbg_massachusetts, chelsea_boundary, sparse = FALSE)[, 1], #DL: For some reason, this does not work with st_intersection
# ] |>
#   filter(
#     # DHL nice job! Antother way to do this is with %nin% the Not IN operator. 
#     # # custom function for "Not In"
#     # `%nin%` <- Negate(`%in%`) # this can be defined in the first chunk. Just expanding your vocabulary
#     !GEOID %in% c(
#       "250173424023", "250173424024", "250173426002", "250173421014",
#       "250173421013", "250251701023", "250251701013", "250251706012"
#     )
#   )

cbgs_chelsea <-
  cbg_massachusetts |> 
  filter(str_detect(GEOID, '25025160')) |> 
  st_intersection(chelsea_boundary)

# mapview(chelsea_boundary, alpha.regions = 0, color = "black", lwd = 5) + mapview(cbg_massachusetts)
mapview(chelsea_boundary, alpha.regions = 0, color = "black", lwd = 5) + mapview(cbgs_chelsea)

## b) Finding CBGs for Holyoke
cbgs_holyoke <- 
  cbg_massachusetts |> 
  filter(str_detect(GEOID, '25013812002') | str_detect(GEOID, '250138119') | str_detect(GEOID, '250138121') |
           str_detect(GEOID, '250138117') | str_detect(GEOID, '250138120') | str_detect(GEOID, '25013811800') |
           str_detect(GEOID, '250138115') | str_detect(GEOID, '250138116') | str_detect(GEOID, '25013811400')
         ) |> 
   st_intersection(holyoke_boundary)

mapview(holyoke_boundary, alpha.regions = 0, color = "black", lwd = 5) + mapview(cbgs_holyoke)

# cbgs_holyoke <- 
#   cbg_massachusetts[
#   st_intersects(cbg_massachusetts, holyoke_boundary, sparse = FALSE)[, 1],
# ] |>
#   filter(!GEOID %in% c(
#     "250138122021", "250138111023", "250138111022", "250138111021",
#     "250138111012", "250138111024", "250138111011", "250138113013",
#     "250158211012", "250158211014", "250158213001", "250158225004",
#     "250158211012", "250158213003", "250158223001", "250158225004",
#     "250138125004", "250158224012", "250158214004"
#   ))
# 
# # DHL I would consider some scruitinzing of these new polygons. Don't just accept them as what you wanted to do. Check for errors | EM: I think it is okay, mhm, seems but not sure.
```

# 2. Downloading the Mass Parcel Data for Holyoke, MA & Chelsea, MA 
```{r}
# 1. Function made through Chat, but it helps me read and query the data/parcels from Holyoke, MA & Chelsea, MA
get_all_parcels <- function(town_name, chunk_size = 1000, geometry = TRUE) {
  base_url <- "https://services1.arcgis.com/hGdibHYSPO59RG1h/arcgis/rest/services/L3_TAXPAR_POLY_ASSESS_gdb/FeatureServer/0/query" #the API/layer I am trying to download data from (couldn't online since it was a viewer)
  result_offset <- 0
  all_features <- list()
  keep_fetching <- TRUE
  
  while (keep_fetching) {
    params <- list(
      where = paste0("CITY='", toupper(town_name), "'"),
      outFields = "*",
      f = "geojson",
      outSR = "4326",
      returnGeometry = ifelse(geometry, "true", "false"),
      resultOffset = result_offset,
      resultRecordCount = chunk_size
    )
    
    resp <- GET(base_url, query = params)
    if (http_error(resp)) stop("Request failed at offset ", result_offset)
    
    features <- st_read(content(resp, "text", encoding = "UTF-8"), quiet = TRUE)
    
    if (nrow(features) == 0) break
    
    all_features[[length(all_features) + 1]] <- features
    result_offset <- result_offset + chunk_size
    keep_fetching <- nrow(features) == chunk_size
  }
  
  do.call(rbind, all_features)
}

# 2. Using the function to acquire all of the properties there
holyoke_properties <- get_all_parcels("Holyoke")
chelsea_properties <- get_all_parcels("Chelsea")

# 3. Reading out both of these property layers

# holyoke_all |>
#   st_write(paste0("/input_data/Holyoke/Boundaries/holyoke_property_value", Sys.Date(), ".gpkg")) DL: This isn't working so I am doing my specific one; not sure why it is not working

holyoke_properties |>
st_write("/Users/eduardosmarin/Desktop/EVST 496 Senior Research Project/03 Data/HERO Front-Backyard/input_data/Holyoke/Boundaries/holyoke_property_value.gpkg")

# chelsea_properties |>
#   st_write(paste0("/input_data/Chelsea/Boundaries/holyoke_property_value", Sys.Date(), ".gpkg")) DL: Same sitatuon as the Holyoke 

chelsea_properties |>
  st_write("/Users/eduardosmarin/Desktop/EVST 496 Senior Research Project/03 Data/HERO Front-Backyard/input_data/Chelsea/Boundaries/chelsea_property_value.gpkg")


```

